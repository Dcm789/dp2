

#if NOOOO
                // 启动TraceDTLP

                // 从断点记忆文件中读出信息
                // return:
                //      -1  error
                //      0   file not found
                //      1   found
                nRet = ReadBatchTaskBreakPointFile("跟踪DTLP数据库",
                    out strBreakPoint,
                    out strError);
                if (nRet == -1)
                {
                    app.WriteErrorLog("ReadBatchTaskBreakPointFile时出错：" + strError);
                }
                // 如果nRet == 0，表示没有断点文件存在，也就不必自动启动这个任务

                // strBreakPoint并未被使用。而是断点文件是否存在，这一信息有价值。

                if (nRet == 1)
                {
                    try
                    {

                        // 从断点文件中取出断点字符串
                        // 断点字符串格式：序号.偏移量@日志文件名
                        //  或者：序号@日志文件名
                        // 获得断点信息的整个过程的代码，是否适宜归入TraceDTLP类？
                        // 如果成熟，可以归纳作为BatchTask基类的一个特性。

                        TraceDTLP tracedtlp = new TraceDTLP(this, null);
                        this.BatchTasks.Add(tracedtlp);

                        if (tracedtlp.StartInfo == null)
                            tracedtlp.StartInfo = new BatchTaskStartInfo();   // 按照缺省值来
                        tracedtlp.StartInfo.Start = "!breakpoint";  //strBreakPoint;
                        tracedtlp.ClearProgressFile();   // 清除进度文件内容
                        tracedtlp.StartWorkerThread();
                    }
                    catch (Exception ex)
                    {
                        app.WriteErrorLog("启动批处理任务时出错：" + ex.Message);
                        goto ERROR1;
                    }
                }

#endif



#if NO
                        bool bLoop = false;
                        string strLastNumber = "";

                        // return:
                        //      -1  出错
                        //      0   没有找到断点信息
                        //      1   找到了断点信息
                        nRet = patron_rep.ReadLastNumber(
                            out bLoop,
                            out strLastNumber,
                            out strError);
                        if (nRet == -1)
                        {
                            app.WriteErrorLog("ReadLastNumber时出错：" + strError);
                        }

                        if (patron_rep.StartInfo == null)
                            patron_rep.StartInfo = new BatchTaskStartInfo();   // 按照缺省值来

                        if (bLoop == true)
                        {
                            // 需要从断点启动
                            if (nRet == 1)
                                patron_rep.StartInfo.Start = "!breakpoint";  //strBreakPoint;

                            patron_rep.ClearProgressFile();   // 清除进度文件内容
                            patron_rep.StartWorkerThread();
                        }
#endif

        // 列出 书目库/读者库/订购库/期库/评注库/发票库/违约金库/预约到书库 检索途径信息
        // parameters:
        //      strLang 语言代码。一般为"zh"
        //      infos   返回检索途径信息数组
        // rights:
        //      需要 listbibliodbfroms 或 listdbfroms 或 order 权限
        // return:
        //      result.Value    -1 出错；0 当前系统中没有定义此类数据库; 1: 成功(有至少一个此类数据库)
        public LibraryServerResult ListBiblioDbFroms(
            string strDbType,
            string strLang,
            out BiblioDbFromInfo[] infos)
        {
            infos = null;

            string strError = "";

            LibraryServerResult result = this.PrepareEnvironment("ListBiblioDbFroms", true, true);
            if (result.Value == -1)
                return result;

            try
            {
                // 权限判断

                // 权限字符串
                if (StringUtil.IsInList("listbibliodbfroms", sessioninfo.RightsOrigin) == false
                    && StringUtil.IsInList("listdbfroms", sessioninfo.RightsOrigin) == false
                    && StringUtil.IsInList("order", sessioninfo.RightsOrigin) == false)
                {
                    result.Value = -1;
                    result.ErrorInfo = "列出书目库检索途径 被拒绝。不具备order或listbibliodbfroms或listdbfroms权限。";
                    result.ErrorCode = ErrorCode.AccessDenied;
                    return result;
                }

                strError = EnsureKdbs(false);
                if (strError != null)
                    goto ERROR1;

                if (string.IsNullOrEmpty(strDbType) == true)
                    strDbType = "biblio";

                // long lRet = 0;

                List<string> dbnames = null;
                if (strDbType == "reader")
                {
                    dbnames = app.GetCurrentReaderDbNameList(sessioninfo.LibraryCodeList);
                }
                else
                {
                    int nRet = app.GetDbNames(
                        strDbType,
                        out dbnames,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;
                }

#if NO
                List<string> dbnames = new List<string>();

                string strDbTypeName = "";

                if (strDbType == "biblio")
                {
                    strDbTypeName = "书目";
                    for (int i = 0; i < app.ItemDbs.Count; i++)
                    {
                        // 实体库对应的书目库名
                        string strBiblioDbName = app.ItemDbs[i].BiblioDbName;

                        if (String.IsNullOrEmpty(strBiblioDbName) == false)
                            dbnames.Add(strBiblioDbName);
                    }
                }
                else if (strDbType == "reader")
                {
                    strDbTypeName = "读者";
                    dbnames = app.GetCurrentReaderDbNameList(sessioninfo.LibraryCodeList);
                }
                else if (strDbType == "item")   // 2012/5/5
                {
                    strDbTypeName = "实体";
                    for (int i = 0; i < app.ItemDbs.Count; i++)
                    {
                        // 实体库名
                        string strItemDbName = app.ItemDbs[i].DbName;

                        if (String.IsNullOrEmpty(strItemDbName) == false)
                            dbnames.Add(strItemDbName);
                    }
                }
                else if (strDbType == "issue")   // 2012/5/5
                {
                    strDbTypeName = "期";
                    for (int i = 0; i < app.ItemDbs.Count; i++)
                    {
                        // 期库名
                        string strIssueDbName = app.ItemDbs[i].IssueDbName;

                        if (String.IsNullOrEmpty(strIssueDbName) == false)
                            dbnames.Add(strIssueDbName);
                    }
                }
                else if (strDbType == "order")   // 2012/5/5
                {
                    strDbTypeName = "订购";
                    for (int i = 0; i < app.ItemDbs.Count; i++)
                    {
                        // 订购库名
                        string strOrderDbName = app.ItemDbs[i].OrderDbName;

                        if (String.IsNullOrEmpty(strOrderDbName) == false)
                            dbnames.Add(strOrderDbName);
                    }
                }
                else if (strDbType == "comment")   // 2012/5/5
                {
                    strDbTypeName = "评注";
                    for (int i = 0; i < app.ItemDbs.Count; i++)
                    {
                        // 实体库名
                        string strCommentDbName = app.ItemDbs[i].CommentDbName;

                        if (String.IsNullOrEmpty(strCommentDbName) == false)
                            dbnames.Add(strCommentDbName);
                    }
                }
                else if (strDbType == "invoice")
                {
                    strDbTypeName = "发票";
                    if (string.IsNullOrEmpty(app.InvoiceDbName) == false)
                        dbnames.Add(app.InvoiceDbName);
                }
                else if (strDbType == "amerce")
                {
                    strDbTypeName = "违约金";
                    if (string.IsNullOrEmpty(app.AmerceDbName) == false)
                        dbnames.Add(app.AmerceDbName);
                }
                else
                {
                    strError = "未知的数据库类型 '"+strDbType+"'。应为biblio reader item issue order comment invoice amerce之一";
                    goto ERROR1;
                }
#endif

                StringUtil.RemoveDupNoSort(ref dbnames);

                if (dbnames.Count == 0)
                {
                    result.Value = 0;
                    result.ErrorInfo = "当前系统中没有定义此类数据库，所以无法获知其检索途径信息";

                    return result;
                }

                // 可以当时现列出，并不存储?
                // 不存储的缺点是，等到发出检索式的时候，就不知道哪个库有哪些style值了。
                // 后退一步：caption可以现列出，但是style值需要预先初始化和存储起来，供检索时构造检索式用
                List<From> froms = new List<From>();

                for (int i = 0; i < dbnames.Count; i++)
                {
                    string strDbName = dbnames[i];

                    if (String.IsNullOrEmpty(strDbName) == true)
                    {
                        Debug.Assert(false, "");
                        continue;
                    }

                    /*
                    // 2011/12/17
                    if (app.kdbs == null)
                    {
                        app.ActivateManagerThreadForLoad();
                        strError = "app.kdbs == null。故障原因请检查dp2Library日志";
                        goto ERROR1;
                    }
                     * */

                    KernelDbInfo db = app.kdbs.FindDb(strDbName);

                    if (db == null)
                    {
                        strError = "kdbs中没有关于"+LibraryApplication.GetDbTypeName(strDbType)+"数据库 '" + strDbName + "' 的信息";
                        goto ERROR1;
                    }

                    // 把所有库的from累加起来
                    froms.AddRange(db.Froms);
                }

                // 根据style值去重
                if (dbnames.Count > 1)
                {
                    if (strDbType != "biblio")
                        KernelDbInfoCollection.RemoveDupByCaption(ref froms,
                            strLang);
                    else
                        KernelDbInfoCollection.RemoveDupByStyle(ref froms);
                }

                List<BiblioDbFromInfo> info_list = new List<BiblioDbFromInfo>();

                int nIndexOfID = -1;    // __id途径所在的下标

                for (int i = 0; i < froms.Count; i++)
                {
                    From from = froms[i];

                    Caption caption = from.GetCaption(strLang);
                    if (caption == null)
                    {
                        caption = from.GetCaption(null);
                        if (caption == null)
                        {
                            strError = "有一个from事项的captions不正常";
                            goto ERROR1;
                        }
                    }

                    if (caption.Value == "__id")
                        nIndexOfID = i;

                    BiblioDbFromInfo info = new BiblioDbFromInfo();
                    info.Caption = caption.Value;
                    info.Style = from.Styles;

                    info_list.Add(info);
                }

                // 如果曾经出现过 __id caption
                if (nIndexOfID != -1)
                {
                    BiblioDbFromInfo temp = info_list[nIndexOfID];
                    info_list.RemoveAt(nIndexOfID);
                    info_list.Add(temp);
                }

                infos = new BiblioDbFromInfo[info_list.Count];
                info_list.CopyTo(infos);

                result.Value = 1;
                result.ErrorInfo = "";

                return result;
                /*
            ERROR1:
                result.Value = -1;
                result.ErrorInfo = strError;
                result.ErrorCode = ErrorCode.SystemError;
                return result;
                 * */
            }
            catch (Exception ex)
            {
                string strErrorText = "dp2Library ListBiblioDbFroms() API出现异常: " + ExceptionUtil.GetDebugText(ex);
                app.WriteErrorLog(strErrorText);

                result.Value = -1;
                result.ErrorCode = ErrorCode.SystemError;
                result.ErrorInfo = strErrorText;
                return result;
            }
        ERROR1:
            result.Value = -1;
            result.ErrorInfo = strError;
            result.ErrorCode = ErrorCode.SystemError;
            return result;
        }

		~~~

		        // 根据源代码文件获得Xml到Html转换的Assembly对象
        public int GetXml2HtmlAssembly(
            string strCodeFileName,
            string strRefFileName,
            string strBinDir,
            out Assembly assembly,
            out string strError)
        {
            strError = "";
            assembly = null;
            int nRet = 0;

#if NO
            // 看看是否已经存在
            this.m_lockXml2HtmlAssemblyTable.AcquireReaderLock(m_nLockTimeout);
            try
            {
                assembly = (Assembly)this.Xml2HtmlAssemblyTable[strCodeFileName.ToLower()];
            }
            finally
            {
                this.m_lockXml2HtmlAssemblyTable.ReleaseReaderLock();
            }
#endif
            assembly = this.AssemblyCache.FindObject(strCodeFileName);

            // 优化
            if (assembly != null)
                return 1;

            string strCode = "";    // c#代码

            // 装入code?
            try
            {
                using (StreamReader sr = new StreamReader(strCodeFileName, true))
                {
                    strCode = sr.ReadToEnd();
                }
            }
            catch (Exception ex)
            {
                strError = ExceptionUtil.GetAutoText(ex);
                return -1;
            }

            string[] saAddRef1 = {

                                    // 2011/9/3 增加
                                    "system.dll",
                                    "system.drawing.dll",
                                    "system.web.dll",
                                    "system.xml.dll",
                                    "System.Runtime.Serialization.dll",

										 strBinDir + "\\digitalplatform.marcdom.dll",
										 strBinDir + "\\digitalplatform.marckernel.dll",
										 strBinDir + "\\digitalplatform.rms.client.dll",
										 strBinDir + "\\digitalplatform.libraryserver.dll",
										 strBinDir + "\\digitalplatform.dll",
										 strBinDir + "\\digitalplatform.Text.dll",
										 strBinDir + "\\digitalplatform.IO.dll",
										 strBinDir + "\\digitalplatform.Xml.dll",
										 // strBinDir + "\\dp2rms.exe",
										 };

            string strWarning = "";
            string strLibPaths = "";

            string[] saRef2 = null;

            if (String.IsNullOrEmpty(strRefFileName) == false)
            {
                // 从references.xml文件中得到refs字符串数组
                // return:
                //		-1	error
                //		0	not found file
                //		1	found file
                nRet = ScriptManager.GetRefs(strRefFileName,
                    out saRef2,
                    out strError);
                if (nRet == -1)
                {
                    strError = "ref文件 '" + strRefFileName + "' 出错: " + strError;
                    return -1;
                }
            }

            string[] saRef = null;
            if (saRef2 != null)
            {
                saRef = new string[saRef2.Length + saAddRef1.Length];
                Array.Copy(saRef2, saRef, saRef2.Length);
                Array.Copy(saAddRef1, 0, saRef, saRef2.Length, saAddRef1.Length);
            }
            else
                saRef = saAddRef1;

            // 创建Script的Assembly
            // 本函数内对saRef不再进行宏替换
            nRet = ScriptManager.CreateAssembly_1(strCode,
                saRef,
                strLibPaths,
                out assembly,
                out strError,
                out strWarning);

            if (nRet == -2)
                goto ERROR1;
            if (nRet == -1)
            {
                strError = "文件 '" + strCodeFileName + "' 编译出错: " + strError;
                if (strWarning == "")
                {
                    goto ERROR1;
                }
                // MessageBox.Show(this, strWarning);

            }

#if NO
            // 加入hashtable
            this.m_lockXml2HtmlAssemblyTable.AcquireWriterLock(m_nLockTimeout);
            try
            {
                this.Xml2HtmlAssemblyTable[strCodeFileName.ToLower()] = assembly;
            }
            finally
            {
                this.m_lockXml2HtmlAssemblyTable.ReleaseWriterLock();
            }
#endif
            this.AssemblyCache.SetObject(strCodeFileName, assembly);
            return 0;
        ERROR1:
            return -1;
        }


		~~~

		        public int PrepareMarcFilter(
            string strFilterFileName,
            out LoanFilterDocument filter,
            out string strError)
        {
            strError = "";

            // 看看是否有现成可用的对象
            filter = (LoanFilterDocument)this.Filters.GetFilter(strFilterFileName);

            if (filter != null)
            {
                // filter.FilterHost = host;
                return 1;
            }

            // 新创建
            // string strFilterFileContent = "";

            filter = new LoanFilterDocument();

            // filter.FilterHost = host;
            filter.strOtherDef = "FilterHost Host = null;";

            filter.strPreInitial = " LoanFilterDocument doc = (LoanFilterDocument)this.Document;\r\n";
            filter.strPreInitial += " Host = ("
                + "FilterHost" + ")doc.FilterHost;\r\n";

            try
            {
                filter.Load(strFilterFileName);
            }
            catch (Exception ex)
            {
                strError = ExceptionUtil.GetAutoText(ex);
                return -1;
            }

            string strCode = "";    // c#代码

            int nRet = filter.BuildScriptFile(out strCode,
                out strError);
            if (nRet == -1)
                goto ERROR1;

            Assembly assembly = null;
            assembly = this.AssemblyCache.FindObject(strFilterFileName);
            if (assembly != null)
            {
                filter.Assembly = assembly;
                return 0;
            }

            string[] saAddRef1 = {
                                    // 2011/9/3 增加
                                    "system.dll",
                                    "system.drawing.dll",
                                    "system.web.dll",
                                    "system.xml.dll",
                                    "System.Runtime.Serialization.dll",

										 this.BinDir + "\\digitalplatform.marcdom.dll",
										 this.BinDir + "\\digitalplatform.marckernel.dll",
										 this.BinDir + "\\digitalplatform.libraryserver.dll",
										 this.BinDir + "\\digitalplatform.dll",
										 this.BinDir + "\\digitalplatform.Text.dll",
										 this.BinDir + "\\digitalplatform.IO.dll",
										 this.BinDir + "\\digitalplatform.Xml.dll",
										 this.BinDir + "\\digitalplatform.script.dll",
										 this.BinDir + "\\digitalplatform.marcquery.dll",
										 /*strMainCsDllName*/ };

            string strWarning = "";
            string strLibPaths = "";

            string[] saRef2 = filter.GetRefs();

            string[] saRef = new string[saRef2.Length + saAddRef1.Length];
            Array.Copy(saRef2, saRef, saRef2.Length);
            Array.Copy(saAddRef1, 0, saRef, saRef2.Length, saAddRef1.Length);

            // 创建Script的Assembly
            // 本函数内对saRef不再进行宏替换
            nRet = ScriptManager.CreateAssembly_1(strCode,
                saRef,
                strLibPaths,
                out assembly,
                out strError,
                out strWarning);
            if (nRet == -2)
                goto ERROR1;
            if (nRet == -1)
            {
                if (strWarning == "")
                {
                    goto ERROR1;
                }
                // MessageBox.Show(this, strWarning);
            }

            filter.Assembly = assembly;
            this.AssemblyCache.SetObject(strFilterFileName, assembly);
            return 0;
        ERROR1:
            return -1;
        }
