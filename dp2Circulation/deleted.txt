        // 提交所有保存请求
        // parameters:
        //      strStyle    风格。displaysuccess 显示最后的成功消息在框架窗口的状态条 verifydata 发送校验记录的消息(注意是否校验还要取决于配置状态)
        //                  searchdup 虽然对本函数没有作用，但是可以传递到下级函数SaveBiblioToDatabase()
        // return:
        //      -1  有错。此时不排除有些信息保存成功。
        //      0   成功。
        /// <summary>
        /// 全部保存
        /// </summary>
        /// <param name="strStyle">保存方式。由 displaysuccess / verifydata / searchdup 之一或者逗号间隔组合而成。displaysuccess 显示最后的成功消息在框架窗口的状态条; verifydata 保存成功后发送校验记录的消息(注意是否校验还要取决于配置状态); searchdup 保存成功后发送查重消息</param>
        /// <returns>-1: 有错。此时不排除有些信息保存成功。0: 成功。</returns>
        public int DoSaveAll(string strStyle = "displaysuccess,verifydata,searchdup")
        {
            bool bBiblioSaved = false;
            int nRet = 0;
            string strText = "";
            int nErrorCount = 0;

            bool bDisplaySuccess = StringUtil.IsInList("displaysuccess", strStyle);
            bool bVerifyData = StringUtil.IsInList("verifydata", strStyle);
            // bool bForceVerifyData = StringUtil.IsInList("forceverifydata", strStyle);

            bool bVerified = false;

            if (this.m_verifyViewer != null)
                this.m_verifyViewer.Clear();

            string strHtml = "";

            LibraryChannel channel = this.GetChannel();
            channel.Timeout = new TimeSpan(0, 5, 0);    // 保存大量册记录时可能会耗时长一点

            Progress.OnStop += new StopEventHandler(this.DoStop);
            Progress.Initial("正在保存记录 ...");
            Progress.BeginLoop();

            this.ShowMessage("正在保存记录 ...");
            try
            {
                if (this.BiblioChanged == true
                    || Global.IsAppendRecPath(this.BiblioRecPath) == true
                    || this.m_bDeletedMode == true /* 2011/11/8 */)
                {
                    // 2014/7/3
                    if (bVerifyData == true
    && this.ForceVerifyData == true)
                    {
                        GenerateDataEventArgs e1 = new GenerateDataEventArgs();
                        e1.FocusedControl = this.m_marcEditor;

                        // 0: 没有发现校验错误; 1: 发现校验警告; 2: 发现校验错误
                        nRet = this.VerifyData(this, e1, true);
                        if (nRet == 2)
                        {
                            MessageBox.Show(this, "MARC 记录经校验发现有错，被拒绝保存。请修改 MARC 记录后重新保存");
                            return -1;
                        }

                        bVerified = true;
                    }

                    // 保存书目记录到数据库
                    // return:
                    //      -1  出错
                    //      0   没有保存
                    //      1   已经保存
                    nRet = SaveBiblioToDatabase(
                        channel,
                        true,
                        out strHtml,
                        strStyle);
                    if (nRet == 1)
                    {
                        bBiblioSaved = true;
                        strText += "书目信息";
                    }
                    if (nRet == -1)
                    {
                        nErrorCount++;
                    }
                }

                bool bOrdersSaved = false;
                // 提交订购保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.orderControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bOrdersSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "采购信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;

                    // 2013/1/18
                    // 如果订购信息保存不成功，则不要继续保存后面的其他信息。这主要是为了订购验收环节考虑，避免在订购信息保存失败的情况下继续保存验收所创建的新的册信息
                    return -1;
                }

                bool bIssuesSaved = false;
                bool bIssueError = false;
                // 提交期保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.issueControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bIssuesSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "期信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;
                    bIssueError = true;

                    // 2013/1/18
                    // 如果期信息保存不成功，则不要继续保存后面的其他信息。这主要是为了期刊验收环节考虑，避免在期信息保存失败的情况下继续保存验收所创建的新的册信息
                    return -1;
                }

                bool bEntitiesSaved = false;

                // 注：在期刊记到后，如果期信息保存不成功，则不保存册信息。以免发生不一致
                if (bIssueError == false)
                {
                    // 提交实体保存请求
                    // return:
                    //      -1  出错
                    //      0   没有必要保存
                    //      1   保存成功
                    nRet = this.entityControl1.DoSaveItems(channel);
                    if (nRet == 1)
                    {
                        bEntitiesSaved = true;
                        if (strText != "")
                            strText += " ";
                        strText += "册信息";
                    }
                    if (nRet == -1)
                    {
                        nErrorCount++;
                    }
                }

                bool bCommentsSaved = false;
                // 提交评注保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.commentControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bCommentsSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "评注信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;
                }

                bool bObjectSaved = false;
                string strError = "";

                // 当允许编目功能的时候才能允许保存对象资源。否则会把书目记录摧毁为空记录
                if (this.Cataloging == true)
                {
                    // 提交对象保存请求
                    // return:
                    //		-1	error
                    //		>=0 实际上载的资源对象数
                    nRet = this.binaryResControl1.Save(
                        channel,
                        this.MainForm.ServerVersion,
                        out strError);
                    if (nRet == -1)
                    {
                        MessageBox.Show(this, "保存对象信息时出错: " + strError);
                        nErrorCount++;
                    }

                    if (nRet >= 1)
                    {
                        bObjectSaved = true;
                        if (strText != "")
                            strText += " ";
                        strText += "对象信息";

                        /*
                        string strSavedBiblioRecPath = this.BiblioRecPath;

                        // 刷新书目记录的时间戳
                        string strOutputBiblioRecPath = "";
                        string strXml = "";
                        nRet = LoadBiblioRecord(this.BiblioRecPath,
                            "",
                            false,
                            out strOutputBiblioRecPath,
                            out strXml,
                            out strError);
                        if (nRet == -1)
                        {
                            // 如果提取记录失败，并且原有书目记录路径被摧毁，需要恢复
                            if (String.IsNullOrEmpty(this.BiblioRecPath) == true)
                            {
                                this.BiblioRecPath = strSavedBiblioRecPath;
                            }

                            MessageBox.Show(this, strError + "\r\n\r\n注意：当前窗口内的书目记录时间戳可能没有正确刷新，这将导致后继的保存书目记录操作出现时间戳不匹配报错");
                            nErrorCount++;
                        }
                        */
                    }
                }

                if (string.IsNullOrEmpty(strHtml) == false)
                {
                    this.m_webExternalHost_biblio.SetHtmlString(strHtml,
    "entityform_biblio");
                }

                if (bDisplaySuccess == true)
                {
                    if (bEntitiesSaved == true
                        || bBiblioSaved == true
                        || bIssuesSaved == true
                        || bOrdersSaved == true
                        || bObjectSaved == true
                        || bCommentsSaved == true)
                        this.MainForm.StatusBarMessage = strText + " 保存 成功";
                }

                if (nErrorCount > 0)
                {
                    return -1;
                }

                // 保存成功后再校验 MARC 记录
                if (bVerifyData == true
                    && this.AutoVerifyData == true
                    && bVerified == false)
                {
                    // TODO: 注意中途关闭 EntityForm 会发生什么
                    API.PostMessage(this.Handle, WM_VERIFY_DATA, 0, 0);
                }

                return 0;
            }
            finally
            {
                if (nErrorCount == 0)
                    this.ShowMessage("记录保存成功", "green", true);
                else
                    this.ShowMessage("记录保存失败", "red", true);

                Progress.EndLoop();
                Progress.OnStop -= new StopEventHandler(this.DoStop);
                Progress.Initial("");

                this.ReturnChannel(channel);
            }
        }


		        // TODO: 有这样一种情况：虽然书目记录和下属的记录都不存在，但是窗口内容被改变了，已然不是以前的内容。如果这时保存记录，会有意外发生，例如本来就有的册信息被清空了。
        // 要想办法在这种情况下保持窗口内全部信息不变；或者，既然已经改变，索性把MARC窗内的记录全部清除，书目记录路径也清楚，避免误会
        // parameters:
        //      bWarningNotSave 是否警告尚未保存？如果==false，并且“自动保存”checkbox为true，会自动保存，不警告
        //      bSetFocus   装载完成后是否把焦点切换到MarcEditor上
        // return:
        //      -1  出错
        //      0   没有装载(例如发现窗口内的记录没有保存，出现警告对话框后，操作者选择了Cancel；或者“到头”“到尾”)
        //      1   成功装载
        //      2   通道被占用
        /// <summary>
        /// 装载记录
        /// </summary>
        /// <param name="strBiblioRecPath">书目记录路径</param>
        /// <param name="strPrevNextStyle">前后翻动风格</param>
        /// <param name="bCheckInUse">是否检查通道占用情况</param>
        /// <param name="bSetFocus">装载完成后是否把焦点切换到MarcEditor上</param>
        /// <param name="strTotalError">返回总的出错情况</param>
        /// <param name="bWarningNotSave">是否警告尚未保存？如果==false，并且“自动保存”checkbox为true，会自动保存，不警告</param>
        /// <returns>
        ///      -1  出错
        ///      0   没有装载(例如发现窗口内的记录没有保存，出现警告对话框后，操作者选择了Cancel；或者“到头”“到尾”)
        ///      1   成功装载
        ///      2   通道被占用
        /// </returns>
        public int LoadRecord(string strBiblioRecPath,
            string strPrevNextStyle,
            bool bCheckInUse,
            bool bSetFocus,
            out string strTotalError,
            bool bWarningNotSave = false)
        {
            strTotalError = "";

            if (Progress.IsInLoop == true && Progress.AllowNest == false)
            {
                strTotalError = "种册窗正在执行长操作。装载书目记录 "
                    + strBiblioRecPath
                    + (string.IsNullOrEmpty(strPrevNextStyle) == true ? "" : "|" + strPrevNextStyle)
                    + " 的操作被放弃。请稍后重试";
                return 2;
            }

            string strError = "";

            bool bMarcEditorContentChanged = false; // MARC编辑器内的内容可曾修改?
            bool bBiblioRecordExist = false;    // 书目记录是否存在?
            bool bSubrecordExist = false;   // 至少有一个从属的记录存在
            bool bSubrecordListCleared = false; // 子记录的list是否被清除了?

            string strOutputBiblioRecPath = "";

            if (this.EntitiesChanged == true
                || this.IssuesChanged == true
                || this.BiblioChanged == true
                || this.ObjectChanged == true
                || this.OrdersChanged == true
                || this.CommentsChanged == true)
            {
                // 2008/6/25 
                if (this.checkBox_autoSavePrev.Checked == true
                    && bWarningNotSave == false)
                {
                    int nRet = this.DoSaveAll();
                    if (nRet == -1)
                    {
                        // strTotalError = "当前记录尚未保存";  // 2014/7/8
                        return -1;
                    }
                }
                else
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。若此时装载新内容，现有未保存信息将丢失。\r\n\r\n确实要装入新内容? ",
                        "EntityForm",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.No)
                        return 0;
                }
            }

            LibraryChannel channel = this.GetChannel();
            TimeSpan old_timeout = channel.Timeout;
            channel.Timeout = new TimeSpan(0, 1, 0);    // 保存大量册记录时可能会耗时长一点

            string strMessage = "正在装载书目记录 " + strBiblioRecPath + " " + strPrevNextStyle + " ...";
            Progress.OnStop += new StopEventHandler(this.DoStop);
            Progress.Initial(strMessage);
            Progress.BeginLoop();

            this.ShowMessage(strMessage);

            EnableControls(false);
            try
            {
                // 2012/7/25 移动到这里
                // 因为 LoadBiblioRecord() 会导致填充AutoGen菜单
                this._genData.ClearViewer();

                if (this.m_commentViewer != null)
                    this.m_commentViewer.Clear();

                bool bLoadSubrecords = true;
                if (StringUtil.CompareVersion(this.MainForm.ServerVersion, "2.91") < 0)
                    bLoadSubrecords = false;


                string strXml = "";
                string strSubRecords = "";
                int nRet = this.LoadBiblioRecord(
                    channel,
                    strBiblioRecPath,
                    strPrevNextStyle,
                    false,
                    bLoadSubrecords,
                    out strOutputBiblioRecPath,
                    out strXml,
                    out strSubRecords,
                    out strError);
                if (nRet == -1)
                {
                    string strErrorText = "装载书目记录 '" + strBiblioRecPath + "' (style='" + strPrevNextStyle + "')时发生错误: " + strError;
#if NO
                            Global.SetHtmlString(this.webBrowser_biblioRecord,
                                strErrorText);
#endif
                    this.m_webExternalHost_biblio.SetHtmlString(strErrorText, "entityform_error");

                    // MessageBox.Show(this, strErrorText);
                    if (String.IsNullOrEmpty(strTotalError) == false)
                        strTotalError += "\r\n";
                    strTotalError += strErrorText;
                }
                else if (nRet == 0)
                {
                    bBiblioRecordExist = false;
                    // 虽然种记录不存在，但是也继续装载册记录
                    // return 0;

                    string strText = "";

                    // 在不是前后翻看记录的情况下，要清空MARC窗，避免误会
                    if (String.IsNullOrEmpty(strPrevNextStyle) == true)
                    {
                        strText = "书目记录 '" + strBiblioRecPath + "' 没有找到...";

                        // 清空MARC窗，避免误会
                        // this.m_marcEditor.Marc = "012345678901234567890123";
                        this.SetMarc("012345678901234567890123");
                        bMarcEditorContentChanged = true;

                        // 如果书目记录不存在，则沿用strBiblioRecPath的路径
                        if (String.IsNullOrEmpty(strOutputBiblioRecPath) == true)
                        {
                            strOutputBiblioRecPath = strBiblioRecPath;
                        }
                    }
                    else
                    {
                        if (strPrevNextStyle == "prev")
                            strText = "到头";
                        else if (strPrevNextStyle == "next")
                            strText = "到尾";

                        strText += "\r\n\r\n(窗口内的原记录没有被刷新)";

                        strOutputBiblioRecPath = "";    // 这时候继续装载下属记录也无法进行了，因为不知道书目记录的路径。TODO: 将来可以采用猜测法，把书目记录路径+1或者-1,直到遇到下一条记录
                        // MessageBox.Show(this, strText);

                        if (String.IsNullOrEmpty(strTotalError) == false)
                            strTotalError += "\r\n";
                        strTotalError += strText;

                        return 0;   // 2008/11/2 
                    }

                    // MessageBox.Show(this, strText);
                    if (String.IsNullOrEmpty(strTotalError) == false)
                        strTotalError += "\r\n";
                    strTotalError += strText;
                }
                else
                {
                    bBiblioRecordExist = true;
                }

                bool bError = false;

                // 注：当bBiblioRecordExist==true时，LoadBiblioRecord()函数中已经设好了书目记录路径

                strBiblioRecPath = null;    // 防止后面继续使用。因为prev/next风格时，strBiblioRecPath的路径并不是所获得的记录的路径

                // 清空4个下属记录的控件
                this.entityControl1.ClearItems();
                this.textBox_itemBarcode.Text = ""; // 2009/1/5 

                this.issueControl1.ClearItems();
                this.orderControl1.ClearItems();   // 2008/11/2 
                this.commentControl1.ClearItems();
                this.binaryResControl1.Clear(); // 2008/11/2 
                if (this.m_verifyViewer != null)
                    this.m_verifyViewer.Clear();
                /*
                if (this.m_genDataViewer != null)
                    this.m_genDataViewer.Clear();
                 * */

                bSubrecordListCleared = true;

                XmlDocument collection_dom = new XmlDocument();
                if (string.IsNullOrEmpty(strSubRecords) == false)
                    collection_dom.LoadXml(strSubRecords);

                if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                {
                    string strBiblioDbName = "";

                    /*
                    if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                        strBiblioDbName = Global.GetDbName(strOutputBiblioRecPath);
                    else
                    {
                        Debug.Assert(String.IsNullOrEmpty(strBiblioRecPath) == false, "");
                        strBiblioDbName = Global.GetDbName(strBiblioRecPath);
                    }
                     * */
                    strBiblioDbName = Global.GetDbName(strOutputBiblioRecPath);

                    // 接着装入相关的所有册
                    string strItemDbName = this.MainForm.GetItemDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strItemDbName) == false) // 仅在当前书目库有对应的实体库时，才装入册记录
                    {
                        this.EnableItemsPage(true);

                        if (IsAccessDenied(collection_dom, "item"))
                            this.entityControl1.ErrorInfo = "权限不足，获取实体信息被拒绝";
                        else
                        {
                            nRet = this.entityControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,    // 2008/11/2 new changed
                                GetItems(collection_dom, "item"),
                                // this.DisplayOtherLibraryItem,
                                this.DisplayOtherLibraryItem == true ? "getotherlibraryitem" : "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载册记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.entityControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableItemsPage(false);
                    }

                    // 接着装入相关的所有期
                    string strIssueDbName = this.MainForm.GetIssueDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strIssueDbName) == false) // 仅在当前书目库有对应的期库时，才装入期记录
                    {
                        this.EnableIssuesPage(true);

                        if (IsAccessDenied(collection_dom, "issue"))
                            this.issueControl1.ErrorInfo = "权限不足，获取期信息被拒绝";
                        else
                        {

                            nRet = this.issueControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,  // 2008/11/2 changed
                                GetItems(collection_dom, "issue"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载期记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.issueControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableIssuesPage(false);
                    }

                    // 接着装入相关的所有订购信息
                    string strOrderDbName = this.MainForm.GetOrderDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strOrderDbName) == false) // 仅在当前书目库有对应的采购库时，才装入采购记录
                    {
                        if (String.IsNullOrEmpty(strIssueDbName) == false)
                            this.orderControl1.SeriesMode = true;
                        else
                            this.orderControl1.SeriesMode = false;

                        this.EnableOrdersPage(true);

                        if (IsAccessDenied(collection_dom, "order"))
                            this.orderControl1.ErrorInfo = "权限不足，获取订购信息被拒绝";
                        else
                        {

                            nRet = this.orderControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,  // 2008/11/2 changed
                                GetItems(collection_dom, "order"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载订购记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.orderControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableOrdersPage(false);
                    }

                    // 接着装入相关的所有评注信息
                    string strCommentDbName = this.MainForm.GetCommentDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strCommentDbName) == false) // 仅在当前书目库有对应的采购库时，才装入采购记录
                    {
                        this.EnableCommentsPage(true);

                        if (IsAccessDenied(collection_dom, "comment"))
                            this.commentControl1.ErrorInfo = "权限不足，获取评注信息被拒绝";
                        else
                        {

                            nRet = this.commentControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,
                                GetItems(collection_dom, "comment"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载评注记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.commentControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableCommentsPage(false);
                    }

                    // 接着装入对象资源
                    {
                        nRet = this.binaryResControl1.LoadObject(
                            channel,
                            strOutputBiblioRecPath,    // 2008/11/2 changed
                            strXml,
                            this.MainForm.ServerVersion,
                            out strError);
                        if (nRet == -1)
                        {
                            strError = "装载对象记录时出错: " + strError;

                            if (channel.ErrorCode == ErrorCode.AccessDenied)
                            {
                                // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                this.binaryResControl1.ErrorInfo = strError;
                            }
                            else
                            {
                                // MessageBox.Show(this, strError);
                                if (String.IsNullOrEmpty(strTotalError) == false)
                                    strTotalError += "\r\n";
                                strTotalError += strError;

                                bError = true;
                                // return -1;
                            }
                        }

                        if (nRet == 1)
                            bSubrecordExist = true;
                    }

                    // 装载书目和<dprms:file>以外的其它XML片断
                    if (string.IsNullOrEmpty(strXml) == false)
                    {
                        nRet = LoadXmlFragment(strXml,
                            out strError);
                        if (nRet == -1)
                        {
                            if (String.IsNullOrEmpty(strTotalError) == false)
                                strTotalError += "\r\n";
                            strTotalError += strError;

                            bError = true;
                        }
                    }
                } // end of if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)

                if (string.IsNullOrEmpty(this.m_strUsedActiveItemPage) == false)
                {
                    // 只要有实体库，即便当前书目记录没有下属的实体记录，也要显示册listview page
                    if (LoadActiveItemIssuePage(m_strUsedActiveItemPage) == true)
                        this.m_strUsedActiveItemPage = "";
                }

                if (bBiblioRecordExist == false && bSubrecordExist == true)
                    this.BiblioRecPath = strOutputBiblioRecPath;

                if (bBiblioRecordExist == false
                    && bSubrecordExist == false
                    && bSubrecordListCleared == true)
                {
                    if (bMarcEditorContentChanged == false)
                    {
                        this.m_marcEditor.Marc = "012345678901234567890123";
                        this.SetMarc("012345678901234567890123");
                        bMarcEditorContentChanged = true;
                    }

                    if (this.DeletedMode == false)
                        this.BiblioRecPath = "";    // 避免残余记录覆盖了不该覆盖的记录
                }

                // 2008/11/2 
                if (bMarcEditorContentChanged == true)
                    this.BiblioChanged = false; // 避免后面自动保存时错误覆盖了不该覆盖的记录

                // 2008/9/16 
                this.DeletedMode = false;

                if (bError == true)
                    return -1;

                // 2013/11/13
                if (bBiblioRecordExist == false
&& bSubrecordExist == false
&& bSubrecordListCleared == true)
                    return -1;

                // 2008/11/26 
                if (m_strFocusedPart == "marceditor"
                    && bSetFocus == true)
                {
                    SwitchFocus(MARC_EDITOR);
                }

                DoViewComment(false);
                return 1;
            }
            finally
            {
                EnableControls(true);

                Progress.EndLoop();
                Progress.OnStop -= new StopEventHandler(this.DoStop);
                Progress.Initial("");

                channel.Timeout = old_timeout;
                this.ReturnChannel(channel);

                // this.m_nChannelInUse--;
                this.ClearMessage();
            }
        }


		        // 移动书目记录
        private void toolStripButton_marcEditor_moveTo_Click(object sender, EventArgs e)
        {
            string strError = "";
            int nRet = 0;

            if (StringUtil.CompareVersion(this.MainForm.ServerVersion, "2.95") < 0)   // "2.39"
            {
                strError = "本功能需要配合 dp2library 2.95 或以上版本才能使用";
                goto ERROR1;
            }

            string strTargetRecPath = this.m_marcEditor.Record.Fields.GetFirstSubfield("998", "t");
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
            {
                DialogResult result = MessageBox.Show(this,
    "当前窗口内的记录原本是从 '" + strTargetRecPath + "' 复制过来的。是否要移动回原有位置？\r\n\r\nYes: 是; No: 否，继续进行普通移动操作; Cancel: 放弃本次操作",
    "EntityForm",
    MessageBoxButtons.YesNoCancel,
    MessageBoxIcon.Question,
    MessageBoxDefaultButton.Button1);
                if (result == System.Windows.Forms.DialogResult.Cancel)
                    return;
                if (result == System.Windows.Forms.DialogResult.Yes)
                {
                    // strTargetRecPath会发生作用
                }

                if (result == System.Windows.Forms.DialogResult.No)
                {
                    strTargetRecPath = "";
                }
            }

            // 源记录就是 ？
            if (Global.IsAppendRecPath(this.BiblioRecPath) == true)
            {
                strError = "源记录尚未建立，无法执行移动操作";
                goto ERROR1;
            }

            // string strMergeStyle = "";
            MergeStyle merge_style = MergeStyle.CombineSubrecord | MergeStyle.ReserveSourceBiblio;

            BiblioSaveToDlg dlg = new BiblioSaveToDlg();
            MainForm.SetControlFont(dlg, this.Font, false);

            dlg.Text = "移动书目记录到 ...";
            dlg.MainForm = this.MainForm;
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
                dlg.RecPath = strTargetRecPath;
            else
            {
                dlg.RecPath = this.MainForm.AppInfo.GetString(
                    "entity_form",
                    "move_to_used_path",
                    this.BiblioRecPath);
                dlg.RecID = "?";
            }

            dlg.MessageText = "将当前窗口中的书目记录 " + this.BiblioRecPath + " (连同下属的册、期、订购、实体记录和对象资源)移动到:";
            dlg.CopyChildRecords = true;
            dlg.EnableCopyChildRecords = false;

            dlg.BuildLink = false;

            {
                string strMarcSyntax = this.GetCurrentMarcSyntax();
                if (string.IsNullOrEmpty(strMarcSyntax) == true)
                    strMarcSyntax = this.MarcSyntax;    // 外来数据的 MARC 格式

                dlg.MarcSyntax = strMarcSyntax;
            }

            // dlg.CurrentBiblioRecPath = this.BiblioRecPath;
            this.MainForm.AppInfo.LinkFormState(dlg, "entityform_BiblioMoveToDlg_state");
            dlg.ShowDialog(this);
            // this.MainForm.AppInfo.UnlinkFormState(dlg);

            if (dlg.DialogResult != DialogResult.OK)
                return;

            if (this.BiblioRecPath == dlg.RecPath)
            {
                strError = "要移动到的位置 '" + dlg.RecPath + "' 和当前记录本来的位置 '" + this.BiblioRecPath + "' 相同，移动操作被拒绝。若确实要这样保存记录，请直接使用保存功能。";
                goto ERROR1;
            }

            this.MainForm.AppInfo.SetString(
    "entity_form",
    "move_to_used_path",
    dlg.RecPath);

            {
                // 如果当前记录没有保存，则先保存
                if (//this.EntitiesChanged == true
                    //|| this.IssuesChanged == true
                    //|| this.BiblioChanged == true
        this.ObjectChanged == true
                    //|| this.OrdersChanged == true
                    //|| this.CommentsChanged == true
                )
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。移动操作前必须先保存当前记录。\r\n\r\n请问要立即保存么？\r\n\r\n(OK: 保存; Cancel: 放弃本次移动操作)",
                        "EntityForm",
                        MessageBoxButtons.OKCancel,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.OK)
                    {
                        // 提交所有保存请求
                        // return:
                        //      -1  有错。此时不排除有些信息保存成功。
                        //      0   成功。
                        nRet = DoSaveAll();
                        if (nRet == -1 || nRet == -2)
                        {
                            strError = "因为保存操作出错，所以后续的移动操作被放弃";
                            goto ERROR1;
                        }
                    }
                    else
                    {
                        strError = "移动操作被放弃";
                        goto ERROR1;
                    }
                }
            }

            // 看看要另存的位置，记录是否已经存在?
            if (dlg.RecID != "?")
            {
                byte[] timestamp = null;

                // 检测特定位置书目记录是否已经存在
                // parameters:
                // return:
                //      -1  error
                //      0   not found
                //      1   found
                nRet = DetectBiblioRecord(dlg.RecPath,
                    out timestamp,
                    out strError);
                if (nRet == 1)
                {
                    //bool bOverwrite = false;
                    if (dlg.RecPath != strTargetRecPath)    // 移动回998$t情况就不询问是否覆盖了，直接选用归并方式
                    {
#if NO
                        // TODO: 用专用对话框实现
                        // 提醒覆盖？
                        DialogResult result = MessageBox.Show(this,
                            "目标书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n要用当前窗口中的书目记录(连同数字对象和下属的子记录)覆盖此记录，还是归并到此记录? \r\n\r\nYes: 覆盖; No: 归并; Cancel: 放弃本次移动操作",
                            "EntityForm",
                            MessageBoxButtons.YesNoCancel,
                            MessageBoxIcon.Question,
                            MessageBoxDefaultButton.Button2);
                        if (result == DialogResult.Cancel)
                            return;
                        if (result == System.Windows.Forms.DialogResult.Yes)
                            bOverwrite = true;
                        else
                            bOverwrite = false;
#endif
                        GetMergeStyleDialog merge_dlg = new GetMergeStyleDialog();
                        MainForm.SetControlFont(merge_dlg, this.Font, false);
                        merge_dlg.SourceRecPath = this.BiblioRecPath;
                        merge_dlg.TargetRecPath = dlg.RecPath;
                        merge_dlg.MessageText = "目标书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n请指定当前窗口中的书目记录(源)和此目标记录合并的方法";

                        merge_dlg.UiState = this.MainForm.AppInfo.GetString(
        "entity_form",
        "GetMergeStyleDialog_uiState",
        "");
                        this.MainForm.AppInfo.LinkFormState(merge_dlg, "entityform_GetMergeStyleDialog_state");
                        merge_dlg.ShowDialog(this);
                        this.MainForm.AppInfo.UnlinkFormState(merge_dlg);
                        this.MainForm.AppInfo.SetString(
"entity_form",
"GetMergeStyleDialog_uiState",
merge_dlg.UiState);

                        if (merge_dlg.DialogResult == System.Windows.Forms.DialogResult.Cancel)
                            return;

                        merge_style = merge_dlg.GetMergeStyle();
                    }

                    // this.BiblioTimestamp = timestamp;   // 为了顺利覆盖

                    // TODO: 预先检查操作者权限，确保删除书目记录和下级记录都能成功，否则就警告

#if NO
                    if (bOverwrite == true)
                    {
                        // 删除目标位置的书目记录
                        // 如果为归并模式，则保留其下属的实体等记录
                        nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                            bOverwrite == true ? "delete" : "onlydeletebiblio",
                            timestamp,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;
                    }
#endif
                    if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                    {
                        // 删除目标记录整个，或者删除目标位置的下级记录
                        // TODO: 测试的时候，注意不用下述调用而测试保留目标书目记录中对象的可能性
                        nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                            (merge_style & MergeStyle.ReserveSourceBiblio) != 0 ? "delete" : "onlydeletesubrecord",
                            timestamp,
                            out strError);
                        if (nRet == -1)
                        {
                            if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 时出错: " + strError;
                            else
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 的全部子记录时出错: " + strError;
                            goto ERROR1;
                        }
                    }
                }
            }

            string strOutputBiblioRecPath = "";
            byte[] baOutputTimestamp = null;
            string strXml = "";

            string strOldBiblioRecPath = this.BiblioRecPath;
            string strOldMarc = this.GetMarc(); //  this.m_marcEditor.Marc;
            bool bOldChanged = this.GetMarcChanged();   // this.m_marcEditor.Changed;
            bool bSucceed = false;

            this.EnableControls(false);

            LibraryChannel channel = this.GetChannel();
            TimeSpan old_timeout = channel.Timeout;
            channel.Timeout = new TimeSpan(0, 2, 0);    // 查重和复制一般都需要较长时间

            try
            {
                // 保存原来的记录路径
                bool bOldReadOnly = this.m_marcEditor.ReadOnly;
                Field old_998 = null;

                string strDlgTargetDbName = Global.GetDbName(dlg.RecPath);
                string str998TargetDbName = Global.GetDbName(strTargetRecPath);

                // 如果移动目标和strTargetRecPath同数据库，则要去掉记录中可能存在的998$t
                if (strDlgTargetDbName == str998TargetDbName)
                {
                    // 保存当前记录的998字段
                    old_998 = this.m_marcEditor.Record.Fields.GetOneField("998", 0);

                    // 清除可能存在的998$t
                    if (old_998 != null)
                    {
                        SubfieldCollection subfields = old_998.Subfields;
                        Subfield old_t = subfields["t"];
                        if (old_t != null)
                        {
                            old_998.Subfields = subfields.Remove(old_t);
                            // 如果998内一个子字段也没有了，是否这个字段要删除?
                        }
                        else
                            old_998 = null; // 表示(既然没有删除$t，就)不用恢复
                    }
                }

                string strMergeStyle = "";
                if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                    strMergeStyle = "reserve_source";
                else
                    strMergeStyle = "reserve_target";

                if ((merge_style & MergeStyle.MissingSourceSubrecord) != 0)
                    strMergeStyle += ",missing_source_subrecord";
                else if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                {
                    // dp2library 尚未实现这个功能，不过本函数前面已经用 SetBiblioInfo() API 主动删除了目标位置下属的子记录，效果是一样的。(当然，这样实现起来原子性不是那么好)
                    // strMergeStyle += ",overwrite_target_subrecord";
                }
                // combine 情况时缺省的，不用声明

                SavedInfo info = new SavedInfo();

                nRet = CopyBiblio(
                    channel,
                    "move",
                    dlg.RecPath,
                    strMergeStyle,
                    out strXml,
                    out strOutputBiblioRecPath,
                    out baOutputTimestamp,
                    out strError);
#if NO
                if (nRet == -1)
                    MessageBox.Show(this, strError);
#endif
                if (nRet == 0)
                {
                    info.bBiblioSaved = true;
                    info.SavedNames.Add("书目信息");
                    this.BiblioChanged = false;
                    this.BiblioRecPath = strOutputBiblioRecPath;
                    this.BiblioTimestamp = baOutputTimestamp;
                    bSucceed = true;
                }
                if (nRet == -1)
                {
                    info.ErrorCount++;
                    goto ERROR1; // 书目记录若保存不成功，后继的实体记录保存就没法定位正确的书目记录路径
                }

                {
                    /// 
                    LoadSubRecordsInfo load_info = new LoadSubRecordsInfo();

                    if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                    {
                        // 装载下级记录，为保存下级记录的修改做准备
                        nRet = LoadSubRecords(
                            channel,
                            strOutputBiblioRecPath,
                            null,   // strXml, // 书目记录 XML
                            "", // strSubRecords,
                            load_info,
                            true,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;
                        // TODO: load_info.ErrorCount ?
                    }

                    nRet = SaveSubRecords(channel,
                        info,
                        strOutputBiblioRecPath,
                        out strError);
                    if (nRet == -1)
                        return;
                }
            }
            finally
            {
                channel.Timeout = old_timeout;
                this.ReturnChannel(channel);

                this.EnableControls(true);

#if NO
                // 复原当前窗口的记录
                if (this.m_marcEditor.Marc != strOldMarc)
                    this.m_marcEditor.Marc = strOldMarc;
                if (this.m_marcEditor.Changed != bOldChanged)
                    this.m_marcEditor.Changed = bOldChanged;
#endif
                if (bSucceed == false)
                {
                    if (this.GetMarc() /*this.m_marcEditor.Marc*/ != strOldMarc)
                    {
                        // this.m_marcEditor.Marc = strOldMarc;
                        this.SetMarc(strOldMarc);
                    }
                    if (this.GetMarcChanged() /*this.m_marcEditor.Changed*/ != bOldChanged)
                    {
                        // this.m_marcEditor.Changed = bOldChanged;
                        this.SetMarcChanged(bOldChanged);
                    }
                    this.BiblioRecPath = strOldBiblioRecPath;
                }
            }

#if NO
            // 将目标记录装入当前窗口
            this.LoadRecordOld(strOutputBiblioRecPath, "", false);
#endif
            return;
        ERROR1:
            MessageBox.Show(this, strError);
        }


		~~~~~~~~~~~~~~~~~

		        void FillItems(List<BiblioStore> items)
        {
            this.ClearMessage();

            StringBuilder text = new StringBuilder();

            string strBinDir = Environment.CurrentDirectory;

            string strCssUrl = Path.Combine(this.MainForm.DataDir, "Order\\BatchOrder.css");
            string strSummaryJs = Path.Combine(this.MainForm.DataDir, "Order\\BatchOrder.js");
            string strLink = "<link href='" + strCssUrl + "' type='text/css' rel='stylesheet' />";
            string strScriptHead = "<script type=\"text/javascript\" src=\"%bindir%/jquery/js/jquery-1.4.4.min.js\"></script>"
                + "<script type=\"text/javascript\" src=\"%bindir%/jquery/js/jquery-ui-1.8.7.min.js\"></script>"
                + "<script type='text/javascript' charset='UTF-8' src='" + strSummaryJs + "'></script>";
            // string strStyle = "<link href=\"%bindir%/select2/select2.min.css\" rel=\"stylesheet\" />" +
            // "<script src=\"%bindir%/select2/select2.min.js\"></script>";
            text.Append("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head>"
                + strLink
                + strScriptHead.Replace("%bindir%", strBinDir)
                // + strStyle.Replace("%bindir%", strBinDir)
                + "</head><body>");

            AppendHtml(text.ToString(), false);
            text.Clear();

            int nStart = 0;
            foreach (BiblioStore item in items)
            {
                // Application.DoEvents();

                text.Append("\r\n<" + TABLE + " class=''>");

                text.Append("\r\n\t<" + TR + " class='check' biblio-recpath='" + item.RecPath + "' " + strOnClick + ">");
                text.Append("\r\n\t\t<" + TD + " class='biblio-index'><div>" + (nStart + 1).ToString() + "</div></" + TD + ">");
                text.Append("\r\n\t\t<" + TD + " class='nowrap' colspan='10'>"
                    + "<div class='biblio-head'>" + HttpUtility.HtmlEncode(item.RecPath) + "</div>"
                    + "<div class='biblio-table-container'>" + BuildBiblioHtml(item.RecPath, item.Xml) + "</div>"
                    + "</" + TD + ">");

                text.Append("\r\n\t</" + TR + ">");

                if (item.Orders.Count > 0)
                {
                    text.Append(GetOrderTitleLine());
                    int i = 0;
                    foreach (OrderStore order in item.Orders)
                    {
                        text.Append(BuildOrderHtml(item.RecPath, order, i, null));

                        i++;
                    }
                }

                nStart++;
                text.Append("\r\n</" + TABLE + ">");

                AppendHtml(text.ToString(), false);
                text.Clear();
            }
            text.Append("</body></html>");

            AppendHtml(text.ToString(), false);
            text.Clear();
#if NO
            Global.SetHtmlString(this.webBrowser1,
    text.ToString(),
    Program.MainForm.DataDir,
    "bo_");
#endif
        }
